
/* An FTL file defines a Resource. */
Resource            ::= (Entry | blank_line | junk_line)*
Entry               ::= (Message line_end)
                      | (Term line_end)
                      | (ResourceComment | GroupComment | Comment)
Message             ::= Comment? Identifier inline_space? "=" inline_space? ((Pattern Attribute*) | (Attribute+))
Term                ::= Comment? TermIdentifier inline_space? "=" inline_space? Value Attribute*
Comment             ::= ("#" ("\u0020" /.*/)? line_end)+
GroupComment        ::= ("##" ("\u0020" /.*/)? line_end)+
ResourceComment     ::= ("###" ("\u0020" /.*/)? line_end)+

/* Adjacent junk_lines should be joined into FTL.Junk during the AST
   construction. */
junk_line           ::= /.*/ line_end

/* Attributes of Messages and Terms. */
Attribute           ::= line_end any_space? "." Identifier inline_space? "=" inline_space? Pattern

/* Value types: Pattern and VariantList. */
Value               ::= Pattern
                      | VariantList
Pattern             ::= PatternElement+
VariantList         ::= any_space? "{" variant_list any_space? "}"
PatternElement      ::= TextElement
                      | Placeable
                      | (break_line inline_space? Placeable)
TextElement         ::= (text_char | text_cont)+
Placeable           ::= "{" any_space? (SelectExpression | InlineExpression) any_space? "}"

/* Rules for validating expressions in Placeables and as selectors of
 * SelectExpressions are documented in spec/valid.md and enforced in
 * syntax/abstract.mjs. */
InlineExpression    ::= StringLiteral
                      | NumberLiteral
                      | VariableReference
                      | CallExpression
                      | AttributeExpression
                      | VariantExpression
                      | MessageReference
                      | TermReference
                      | Placeable

/* Literals */
StringLiteral       ::= quote quoted_text_char* quote
NumberLiteral       ::= "-"? digit+ ("." digit+)?

/* Inline Expressions */
MessageReference    ::= Identifier
TermReference       ::= TermIdentifier
VariableReference   ::= VariableIdentifier
CallExpression      ::= Function any_space? "(" any_space? argument_list any_space? ")"
argument_list       ::= (Argument any_space? "," any_space?)* Argument?
Argument            ::= NamedArgument
                      | InlineExpression
NamedArgument       ::= Identifier any_space? ":" any_space? (StringLiteral | NumberLiteral)
AttributeExpression ::= (MessageReference | TermReference) "." Identifier
VariantExpression   ::= TermReference VariantKey

/* Block Expressions */
SelectExpression    ::= InlineExpression inline_space? "->" inline_space? variant_list
variant_list        ::= Variant* DefaultVariant Variant* line_end
Variant             ::= line_end any_space? VariantKey inline_space? Value
DefaultVariant      ::= line_end any_space? "*" VariantKey inline_space? Value
VariantKey          ::= "[" any_space? (NumberLiteral | VariantName) any_space? "]"
VariantName         ::= word (any_space word)*

/* Identifiers */
Identifier          ::= identifier
TermIdentifier      ::= "-" identifier
VariableIdentifier  ::= "$" identifier
Function            ::= [A-Z] [A-Z_?-]*

/* Tokens */
identifier          ::= [a-zA-Z] [a-zA-Z0-9_-]*
word                ::= (regular_char - backslash - "}" - "{" - "]" - "[" - "=")+

/* Characters */
backslash           ::= "\\"
quote               ::= "\""
/* Any Unicode character from BMP excluding C0 control characters, space,
 * surrogate blocks and non-characters (U+FFFE, U+FFFF).
 * Cf. https://www.w3.org/TR/REC-xml/#NT-Char
 * TODO Add characters from other planes: U+10000 to U+10FFFF.
 */
regular_char        ::= [!-\uD7FF\uE000-\uFFFD]
text_char           ::= inline_space
                      | /\\u[0-9a-fA-F]{4}/
                      | (backslash backslash)
                      | (backslash "{")
                      | (regular_char - "{" - backslash)
text_cont           ::= break_line inline_space (text_char - "}" - "[" - "*" - ".")
quoted_text_char    ::= (text_char - quote)
                      | (backslash quote)
digit               ::= [0-9]

/* Whitespace */
inline_space        ::= ("\u0020" | "\u0009")+
line_end            ::= "\u000D\u000A"
                      | "\u000A"
                      | EOF
blank_line          ::= inline_space? line_end
break_line          ::= line_end blank_line*
any_space           ::= (inline_space | line_end)+
